if (!require("cluster")) install.packages("cluster")
library(cluster)

library(readr)
dataset <- read_csv("C:/Users/emont/OneDrive/Escritorio/Tesis/MILP/Datasets/Datasets/Large/bank.csv")

X <- dataset[, -c(1,10)]
y <- dataset$Personal.Loan

n2 <-c(4520, 480)
k = length(n2)

# Compute the distance matrix
if (!require("proxy")) install.packages("proxy")
library(proxy)
D <- proxy::dist(as.matrix(X), method = "cosine")
D = as.matrix(D)
distance = D

#===========================================================================================================
# PLCSC ALGORITHM PROCESS

r <- nrow(D) # Total number of instances

cl = kmeans(X, k)
c = cl$size

n2 <- matrix(n2 - 1, ncol = 1) # (excluding centroids)
v <- 1:r # Vector of total number of instances
v <- v[!v %in% c] # Remove centroids from the dataset
D <- D[-v, ] # Remove all rows except centroid rows
f1 <- as.vector(t(D)) # Convert rows into a vector
D <- D[, -c] # Remove centroid columns

f <- as.vector(t(D)) # Convert rows into a vector (clean objective function)
DDD = as.data.frame(f)

# Construction of constraint matrices
Aeq1 <- matrix(0, nrow = k, ncol = length(f))
for (i in 1:ncol(D)) {
  for (j in 1:k) {
    Aeq1[j, i + (j - 1) * ncol(D)] <- 1
  }
}

Aeq2 <- diag(ncol(D))
for (i in 1:(k - 1)) {
  Aeq2 <- cbind(Aeq2, diag(ncol(D)))
}

Aeq <- rbind(Aeq1, Aeq2)
beq <- c(n2, rep(1, ncol(D))) # n1 = equal size, n2 = different size

# Binary Linear Programming Model
if (!require("lpSolve")) install.packages("lpSolve")
library(lpSolve)

intcon <- seq_along(f)
lb <- rep(0, length(f))
ub <- rep(1, length(f))

# Assuming no inequality constraints in this case
A <- Aeq
dir <- c(rep("==", nrow(Aeq)))
rhs <- beq

# Call to lp() function
result <- lp(direction = "min",
             objective.in = f,
             const.mat = A,
             const.dir = dir,
             const.rhs = rhs,
             all.bin = TRUE)

x <- result$solution
fval <- result$objval

s1 <- matrix(x, nrow = k, byrow = TRUE)
s2 <- diag(k)
st <- matrix(0, nrow = k, ncol = r)
st[, c] <- s2
st[, v] <- s1

label_pred <- numeric(r)
for (i in 1:k) {
  ind <- which(st[i, ] == 1)
  label_pred[ind] <- i
}

# Index vector of documents ordered by cluster (PLCSC solution)
index <- unlist(lapply(1:k, function(i) which(label_pred == i)))

#================================================================================================================
X_mat <- as.matrix(X)
X_norms <- sqrt(rowSums(X_mat^2)) + 1e-10
X_norm <- X_mat / X_norms

# Compute centroids generated by PLCSC
u_labels <- sort(unique(label_pred))
centroids <- matrix(0, nrow = length(u_labels), ncol = ncol(X_mat))
for(i in seq_along(u_labels)) {
  mask <- (label_pred == u_labels[i])
  if(sum(mask) == 1) centroids[i,] <- X_mat[mask,] 
  else centroids[i,] <- colMeans(X_mat[mask,])
}

# Compute Cosine Distances (Point-to-Centroid)
c_norms <- sqrt(rowSums(centroids^2)) + 1e-10
c_norm <- centroids / c_norms
dists <- 1 - tcrossprod(X_norm, c_norm)
dists[dists < 0] <- 0

# Compute a(i) and b(i)
idx <- cbind(1:nrow(X), match(label_pred, u_labels))
a_i <- dists[idx]            # Distance to its own centroid
dists[idx] <- Inf            # Ignore own centroid to search nearest neighbor
b_i <- apply(dists, 1, min)  # Distance to nearest neighboring centroid

sil_compatible <- mean((b_i - a_i) / pmax(a_i, b_i), na.rm = TRUE)

# 4. Final Metrics
cat("--------------------------------------------------\n")
cat("Silhouette (Centroid-based Logic):", sil_compatible, "\n")
cat("ARI                            :", ARI(y, label_pred), "\n")
cat("AMI                            :", AMI(y, label_pred), "\n")
cat("NMI                            :", NMI(y, label_pred), "\n")
cat("--------------------------------------------------\n")

# Counts
cat("\nGround Truth Groups:\n"); print(table(y))
cat("\nCSCLP Groups:\n"); print(table(label_pred))
