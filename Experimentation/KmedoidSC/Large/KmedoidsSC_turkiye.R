if (!require("cluster")) install.packages("cluster")
library(cluster)

library(readr)
dataset <- read_csv("C:/Users/emont/OneDrive/Escritorio/Tesis/MILP/Datasets/Datasets/Large/turkiye.csv")

X <- dataset[, 3:33]
y <- dataset$class

E <- c(775,1444,3601)
K = length(E)
cl = pam(X, K)
C = cl$id.med

# Compute the distance matrix
if (!require("proxy")) install.packages("proxy")
library(proxy)
D <- proxy::dist(as.matrix(X), method = "cosine")
D = as.matrix(D)

###########################################################################

SC_medoids <- function(D, k, E, C = NULL) {
  if (is.null(C)) {
    C <- sample(1:nrow(D), k)
  }
  
  # Initially, assign each point to the nearest medoid
  cl <- max.col(-D[, C, drop = FALSE])
  
  # Sort points by their distance to the nearest medoid
  sorted_points <- order(apply(D[, C, drop = FALSE], 1, min))
  
  # Assign the first E[i] points to each cluster i
  for (i in 1:k) {
    cl[sorted_points[1:E[i]]] <- i
    sorted_points <- sorted_points[-(1:E[i])]
  }
  
  # Assign remaining points to the nearest medoid
  for (point in sorted_points) {
    cl[point] <- which.min(D[point, C])
  }
  
  # Assign cluster labels to each point
  labels <- numeric(nrow(D))
  for (i in 1:k) {
    ii <- which(cl == i)
    labels[ii] <- i
  }
  
  # Return results: medoids, clustering, and labels
  return(list(medoids = C, clustering = cl, labels = labels))
}

result <- SC_medoids(D, K, E, C)
label_pred <- result$labels  # Assignment of points to clusters

###########################################################################
X_mat <- as.matrix(X)
X_norms <- sqrt(rowSums(X_mat^2)) + 1e-10
X_norm <- X_mat / X_norms

# Compute centroids generated by SC-Medoids
u_labels <- sort(unique(label_pred))
centroids <- matrix(0, nrow = length(u_labels), ncol = ncol(X_mat))
for(i in seq_along(u_labels)) {
  mask <- (label_pred == u_labels[i])
  if(sum(mask) == 1) centroids[i,] <- X_mat[mask,] 
  else centroids[i,] <- colMeans(X_mat[mask,])
}

# Compute Cosine Distances (Point-to-Centroid)
c_norms <- sqrt(rowSums(centroids^2)) + 1e-10
c_norm <- centroids / c_norms
dists <- 1 - tcrossprod(X_norm, c_norm)
dists[dists < 0] <- 0

# Compute a(i) and b(i)
idx <- cbind(1:nrow(X), match(label_pred, u_labels))
a_i <- dists[idx]            # Distance to its own centroid
dists[idx] <- Inf            # Ignore own centroid to search for nearest neighbor
b_i <- apply(dists, 1, min)  # Distance to the nearest neighboring centroid

sil_compatible <- mean((b_i - a_i) / pmax(a_i, b_i), na.rm = TRUE)

# 4. Final Metrics
cat("--------------------------------------------------\n")
cat("Silhouette (Centroid-based Logic):", sil_compatible, "\n")
cat("ARI                            :", ARI(y, label_pred), "\n")
cat("AMI                            :", AMI(y, label_pred), "\n")
cat("NMI                            :", NMI(y, label_pred), "\n")
cat("--------------------------------------------------\n")

# Counts
cat("\nGround Truth Groups:\n"); print(table(y))
cat("\nK-MedoidsSC Groups:\n"); print(table(label_pred))